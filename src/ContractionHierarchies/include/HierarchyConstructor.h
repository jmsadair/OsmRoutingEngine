#pragma once
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include "Graph.h"
#include "Queue.h"

/**
* The purpose of this class is to take a weighted, directed graph and modify it so that it can be used for optimal routing
* in road networks. The vertices in the graph are ordered by importance and then a hierarchy is generated by
* iteratively "contracting" the least important Vertex. Contracting a Vertex v means to
* replace the shortest paths going through v by "shortcuts".
*
* NOTE: In general, we will use v to denote vertices that have an outgoing Edge to the Vertex being contracted i.e. v -> u, where
* u is the Vertex that is being contracted. We will use w to denote vertices that the contracted Vertex has an
* outgoing Edge to i.e. u -> w. We will also use the term "witness path". Suppose that u is a Vertex being contracted.
* A witness path from Vertex v to Vertex w is a path that does not contain u such that weight(path(v, w)) <= weight(v -> u -> w).
*/
class HierarchyConstructor {

private:

    Graph& graph_;

    long long total_edges_added_;

    std::unordered_map<uint64_t, Vertex> vertices_;

    /**
    * This method is used to contract a Vertex. If simulated is set to true, no edges will be added. If simulated is set to
    * false, the necessary shortcut edges will be added to the graph. The purpose of simulating the contraction of a Vertex
    * is to determine the cost of contracting the Vertex. The cost of contracting a Vertex is the number of shortcut edges
    * that must be added when we remove the Vertex from the graph.
    */
    int contract_vertex(uint64_t contracted_vertex, int hop_limit, bool simulated = false);

    /**
    * The purpose of this method is to find witness paths between vertices. We find witness paths by applying a
    * standard unidirectional Dijkstra algorithm. The hop limit is the maximum number of vertices that we will allow to be
    * in the shortest path. If the hop limit is exceeded, we terminate the search. If u is the Vertex being contracted,
    * then ehe maximum weight is weight(v, u) + max(weight(u, w)). We can abort the search if this weight is exceeded, because there
    * is then no hope of finding a witness path. We can also abort the search if we have settled all outgoing vertices of the Vertex being
    * contracted.
    */
    std::unordered_map<uint64_t, double> witness_search(uint64_t source, uint64_t contracted_vertex, double max_distance, int hop_limit);

    /**
    * This method updates the deleted neighbor counter of all vertices adjacent to the Vertex being contracted.
    * The deleted neighbor counter is used when determining the priority term of a Vertex. The deleted neighbor counter
    * ensures uniform contraction of nodes across the graph. Uniform contraction of nodes reduces preprocessing time and
    * improves route query time.
    */
    void contracted_neighbors(uint64_t contracted_vertex);

    /**
    * During the contraction of a node, the necessary shortcuts are gathered in a vector. This method adds those shortcuts
    * to the graph.
    */
    void add_shortcuts(uint64_t contracted_vertex, const std::vector<std::tuple<unsigned long long, unsigned long long, double>>* shortcuts);

    /**
    * This method computes the Edge difference when a Vertex is contracted. The Edge difference for a Vertex u is given
    * by the number of shortcuts that must be added when u is contracted minus the total number of incoming and outgoing edges
    * that u has.
    */
    int get_edge_difference(uint64_t contracted_vertex, int hop_limit);


    // Determines the maximum outgoing Edge weight of a Vertex being contracted.
    double get_max_out_distance(uint64_t contracted_vertex) const;

    /**
    * This method gets the next Vertex that is to be contracted. We check to see if the next Vertex
    * in the Queue still has the minimum cost by simulating its contraction. If the Vertex no longer
    * has the minimum cost, the Queue is updated and we again check to see if the next Vertex in the
    * Queue has the minimum cost. This process continues until we successfully find a Vertex that still
    * has the minimum cost after a simulated contraction.
    */
    unsigned long long get_next(int hop_limit, Queue<HeapElement>* queue);

    /**
    * This method is used to compute the cost of contraction of all the vertices in the graph. A minimum binary heap is used
    * to store the vertices and their associated cost.
    */
    Queue<HeapElement> get_initial_ordering(int hop_limit);

    // Simulates the contraction of a Vertex and computes its cost of contraction.
    int get_priority_term(uint64_t contracted_vertex, int hop_limit, bool simulated = false);

public:

    // We take a reference to the graph because we will be adding edges to it as the contraction process takes place.
    explicit HierarchyConstructor(Graph& graph);

    // This method contracts all the vertices in the graph and adds any necessary shortcuts.
    void contract_graph();
};